<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Multithreaded Execution - The Rustonomicon</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/nomicon.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> Meet Safe and Unsafe</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> How Safe and Unsafe Interact</a></li><li class="chapter-item expanded "><a href="../what-unsafe-does.html"><strong aria-hidden="true">1.2.</strong> What Unsafe Can Do</a></li><li class="chapter-item expanded "><a href="../working-with-unsafe.html"><strong aria-hidden="true">1.3.</strong> Working with Unsafe</a></li></ol></li><li class="chapter-item expanded "><a href="../data.html"><strong aria-hidden="true">2.</strong> Data Layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li class="chapter-item expanded "><a href="../exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> Exotically Sized Types</a></li><li class="chapter-item expanded "><a href="../other-reprs.html"><strong aria-hidden="true">2.3.</strong> Other reprs</a></li></ol></li><li class="chapter-item expanded "><a href="../ownership.html"><strong aria-hidden="true">3.</strong> Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../references.html"><strong aria-hidden="true">3.1.</strong> References</a></li><li class="chapter-item expanded "><a href="../aliasing.html"><strong aria-hidden="true">3.2.</strong> Aliasing</a></li><li class="chapter-item expanded "><a href="../lifetimes.html"><strong aria-hidden="true">3.3.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="../lifetime-mismatch.html"><strong aria-hidden="true">3.4.</strong> Limits of Lifetimes</a></li><li class="chapter-item expanded "><a href="../lifetime-elision.html"><strong aria-hidden="true">3.5.</strong> Lifetime Elision</a></li><li class="chapter-item expanded "><a href="../unbounded-lifetimes.html"><strong aria-hidden="true">3.6.</strong> Unbounded Lifetimes</a></li><li class="chapter-item expanded "><a href="../hrtb.html"><strong aria-hidden="true">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class="chapter-item expanded "><a href="../subtyping.html"><strong aria-hidden="true">3.8.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="../dropck.html"><strong aria-hidden="true">3.9.</strong> Drop Check</a></li><li class="chapter-item expanded "><a href="../phantom-data.html"><strong aria-hidden="true">3.10.</strong> PhantomData</a></li><li class="chapter-item expanded "><a href="../borrow-splitting.html"><strong aria-hidden="true">3.11.</strong> Splitting Borrows</a></li></ol></li><li class="chapter-item expanded "><a href="../conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../coercions.html"><strong aria-hidden="true">4.1.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="../dot-operator.html"><strong aria-hidden="true">4.2.</strong> The Dot Operator</a></li><li class="chapter-item expanded "><a href="../casts.html"><strong aria-hidden="true">4.3.</strong> Casts</a></li><li class="chapter-item expanded "><a href="../transmutes.html"><strong aria-hidden="true">4.4.</strong> Transmutes</a></li></ol></li><li class="chapter-item expanded "><a href="../uninitialized.html"><strong aria-hidden="true">5.</strong> Uninitialized Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../checked-uninit.html"><strong aria-hidden="true">5.1.</strong> Checked</a></li><li class="chapter-item expanded "><a href="../drop-flags.html"><strong aria-hidden="true">5.2.</strong> Drop Flags</a></li><li class="chapter-item expanded "><a href="../unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> Unchecked</a></li></ol></li><li class="chapter-item expanded "><a href="../obrm.html"><strong aria-hidden="true">6.</strong> Ownership Based Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../constructors.html"><strong aria-hidden="true">6.1.</strong> Constructors</a></li><li class="chapter-item expanded "><a href="../destructors.html"><strong aria-hidden="true">6.2.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="../leaking.html"><strong aria-hidden="true">6.3.</strong> Leaking</a></li></ol></li><li class="chapter-item expanded "><a href="../unwinding.html"><strong aria-hidden="true">7.</strong> Unwinding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exception-safety.html"><strong aria-hidden="true">7.1.</strong> Exception Safety</a></li><li class="chapter-item expanded "><a href="../poisoning.html"><strong aria-hidden="true">7.2.</strong> Poisoning</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency.html"><strong aria-hidden="true">8.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../races.html"><strong aria-hidden="true">8.1.</strong> Races</a></li><li class="chapter-item expanded "><a href="../send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="../atomics/atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../atomics/multithread.html" class="active"><strong aria-hidden="true">8.3.1.</strong> Multithreaded Execution</a></li><li class="chapter-item expanded "><a href="../atomics/relaxed.html"><strong aria-hidden="true">8.3.2.</strong> Relaxed</a></li><li class="chapter-item expanded "><a href="../atomics/acquire-release.html"><strong aria-hidden="true">8.3.3.</strong> Acquire and Release</a></li><li class="chapter-item expanded "><a href="../atomics/seqcst.html"><strong aria-hidden="true">8.3.4.</strong> SeqCst</a></li><li class="chapter-item expanded "><a href="../atomics/fences.html"><strong aria-hidden="true">8.3.5.</strong> Fences</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../vec/vec.html"><strong aria-hidden="true">9.</strong> Implementing Vec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../vec/vec-layout.html"><strong aria-hidden="true">9.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="../vec/vec-alloc.html"><strong aria-hidden="true">9.2.</strong> Allocating</a></li><li class="chapter-item expanded "><a href="../vec/vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> Push and Pop</a></li><li class="chapter-item expanded "><a href="../vec/vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> Deallocating</a></li><li class="chapter-item expanded "><a href="../vec/vec-deref.html"><strong aria-hidden="true">9.5.</strong> Deref</a></li><li class="chapter-item expanded "><a href="../vec/vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> Insert and Remove</a></li><li class="chapter-item expanded "><a href="../vec/vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="../vec/vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li class="chapter-item expanded "><a href="../vec/vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li class="chapter-item expanded "><a href="../vec/vec-zsts.html"><strong aria-hidden="true">9.10.</strong> Handling Zero-Sized Types</a></li><li class="chapter-item expanded "><a href="../vec/vec-final.html"><strong aria-hidden="true">9.11.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-and-mutex.html"><strong aria-hidden="true">10.</strong> Implementing Arc and Mutex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arc-mutex/arc.html"><strong aria-hidden="true">10.1.</strong> Arc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arc-mutex/arc-layout.html"><strong aria-hidden="true">10.1.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-base.html"><strong aria-hidden="true">10.1.2.</strong> Base Code</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-clone.html"><strong aria-hidden="true">10.1.3.</strong> Cloning</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-drop.html"><strong aria-hidden="true">10.1.4.</strong> Dropping</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-final.html"><strong aria-hidden="true">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../ffi.html"><strong aria-hidden="true">11.</strong> FFI</a></li><li class="chapter-item expanded "><a href="../beneath-std.html"><strong aria-hidden="true">12.</strong> Beneath std</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../panic-handler.html"><strong aria-hidden="true">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/nomicon" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="multithreaded-execution"><a class="header" href="#multithreaded-execution">Multithreaded Execution</a></h1>
<p>When you write Rust code to run on your computer, it may surprise you but you’re
not actually writing Rust code to run on your computer — instead, you’re writing
Rust code to run on the <em>abstract machine</em> (or AM for short). The abstract
machine, to be contrasted with the physical machine, is an abstract
representation of a theoretical computer: it doesn’t actually exist <em>per se</em>,
but the combination of a compiler, target architecture and target operating
system is capable of emulating a subset of its possible behaviours.</p>
<p>The Abstract Machine has a few properties that are essential to understand:</p>
<ol>
<li>It is architecture and OS-independent. The Abstract Machine doesn’t care
whether you’re on x86_64 or iOS or a Nintendo 3DS, the rules are the same
for everyone. This enables you to write code without having to think about
what the underlying system does or how it does it, as long as you obey the
Abstract Machine’s rules you know you’ll be fine.</li>
<li>It is the lowest common denominator of all supported computer systems. This
means it is allowed to result in executions no sane computer would actually
generate in real life. It is also purposefully built with forward
compatibility in mind, giving compilers the opportunity to make better and
more aggressive optimizations in the future. As a result, it can be quite
hard to test code, especially if you’re on a system that exploits fewer of
the AM’s allowed semantics, so it is highly recommended to utilize tools
that intentionally produce these executions like <a href="https://docs.rs/loom">Loom</a> and <a href="https://github.com/rust-lang/miri">Miri</a>.</li>
<li>Its model is highly formalized and not representative of what goes on
underneath. Because C++ needs to be defined by a formal specification and
not just hand-wavy rules about “this is what allowed and this is what
isn’t”, the Abstract Machine defines things in a very mathematical and,
well, <em>abstract</em>, way; instead of saying things like “the compiler is
allowed to do X” it will find a way to define the system such that the
compiler’s ability to do X simply follows as a natural consequence. This
makes it very elegant and keeps the mathematicians happy, but you should
keep in mind that this is not how computers actually function, it is merely
a representation of it.</li>
</ol>
<p>With that out of the way, let’s look into how the C++20 Abstract Machine is
actually defined.</p>
<p>The first important thing to understand is that <strong>the abstract machine has no
concept of time</strong>. You might expect there to be a single global ordering of
events across the program where each happens at the same time or one after the
other, but under the abstract model no such ordering exists; instead, a possible
execution of the program must be treated as a single event that happens
instantaneously. There is never any such thing as “now”, or a “latest value”,
and using that terminology will only lead you to more confusion. Of course, in
reality there does exist a concept of time, but you must keep in mind that
you’re not programming for the hardware, you’re programming for the AM.</p>
<p>However, while no global ordering of operations exists <em>between</em> threads, there
does exist a single total ordering <em>within</em> each thread, which is known as its
<em>sequence</em>. For example, given this simple Rust program:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;A&quot;);
println!(&quot;B&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>its sequence during one possible execution can be visualized like so:</p>
<pre><code class="language-text">╭───────────────╮
│ println!(&quot;A&quot;) │
╰───────╥───────╯
╭───────⇓───────╮
│ println!(&quot;B&quot;) │
╰───────────────╯
</code></pre>
<p>That double arrow in between the two boxes (<code>⇒</code>) represents that the second
statement is <em>sequenced-after</em> the first (and similarly the first statement is
<em>sequenced-before</em> the second). This is the strongest kind of ordering guarantee
between any two operations, and only comes about when those two operations
happen one after the other and on the same thread.</p>
<p>If we add a second thread to the mix:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Thread 1:
println!(&quot;A&quot;);
println!(&quot;B&quot;);
// Thread 2:
eprintln!(&quot;01&quot;);
eprintln!(&quot;02&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>it will simply coexist in parallel, with each thread getting its own independent
sequence:</p>
<pre><code class="language-text">    Thread 1              Thread 2
╭───────────────╮    ╭─────────────────╮
│ println!(&quot;A&quot;) │    │ eprintln!(&quot;01&quot;) │
╰───────╥───────╯    ╰────────╥────────╯
╭───────⇓───────╮    ╭────────⇓────────╮
│ println!(&quot;B&quot;) │    │ eprintln!(&quot;02&quot;) │
╰───────────────╯    ╰─────────────────╯
</code></pre>
<p>We can say that the prints of <code>A</code> and <code>B</code> are <em>unsequenced</em> with regard to the
prints of <code>01</code> and <code>02</code> that occur in the second thread, since they have no
sequenced-before arrows connecting the boxes together.</p>
<p>Note that these diagrams are <strong>not</strong> a representation of multiple things that
<em>could</em> happen at runtime — instead, this diagram describes exactly what <em>did</em>
happen when the program ran once. This distinction is key, because it highlights
that even the lowest-level representation of a program’s execution does not have
a global ordering between threads; those two disconnected chains are all there
is.</p>
<p>Now let’s make things more interesting by introducing some shared data, and have
both threads read it.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initial state
let data = 0;
// Thread 1:
println!(&quot;{data}&quot;);
// Thread 2:
eprintln!(&quot;{data}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Each memory location, similarly to threads, can be shown as another column on
our diagram, but holding values instead of instructions, and each access (read
or write) manifests as a line from the instruction that performed the access to
the associated value in the column. So this code can produce (and is in fact
guaranteed to produce) the following execution:</p>
<pre><code class="language-text">Thread 1     data     Thread 2
╭──────╮    ┌────┐    ╭──────╮
│ data ├╌╌╌╌┤  0 ├╌╌╌╌┤ data │
╰──────╯    └────┘    ╰──────╯
</code></pre>
<p>That is, both threads read the same value of <code>0</code> from <code>data</code>, and the two
operations are unsequenced — they have no relative ordering between them.</p>
<p>That’s reads done, so we’ll look at the other kind of data access next: writes.
We’ll also return to a single thread for now, just to keep things simple.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = 0;
data = 1;
<span class="boring">}
</span></code></pre></pre>
<p>Here, we have a single variable that the main thread writes to once — this means
that in its lifetime, it holds two values, first <code>0</code>, and then <code>1</code>.
Diagrammatically, this code’s execution can be represented like so:</p>
<pre><code class="language-text"> Thread 1        data
╭───────╮       ┌────┐
│  = 1  ├╌╌╌┐   │  0 │
╰───────╯   ├╌╌╌┼╌╌╌╌┤
            └╌╌╌┼╌╌╌╌┤
                │  1 │
                └────┘
</code></pre>
<p>Note the use of dashed padding in between the values of <code>data</code>’s column. Those
spaces won’t ever contain a value, but they’re used to represent an
unsynchronized (non-atomic) write — it is garbage data and attempting to read it
would result in a data race.</p>
<p>Now let’s put all of our knowledge thus far together, and make a program both
that reads <em>and</em> writes data — woah, scary!</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = 0;
data = 1;
println!(&quot;{data}&quot;);
data = 2;
<span class="boring">}
</span></code></pre></pre>
<p>Working out executions of code like this is rather like solving a Sudoku puzzle:
you must first lay out all the facts that you know, and then fill in the blanks
with logical reasoning. The initial information we’ve been given is both the
initial value of <code>data</code> and the sequential order of Thread 1; we also know that
over its lifetime, <code>data</code> takes on a total of three different values that were
caused by two different non-atomic writes. This allows us to start drawing out
some boxes:</p>
<pre><code class="language-text"> Thread 1        data
╭───────╮       ┌────┐
│  = 1  ├╌?     │  0 │
╰───╥───╯     ?╌┼╌╌╌╌┤
╭───⇓───╮     ?╌┼╌╌╌╌┤
│  data ├╌?     │  ? │
╰───╥───╯     ?╌┼╌╌╌╌┤
╭───⇓───╮     ?╌┼╌╌╌╌┤
│  = 2  ├╌?     │  ? │
╰───────╯       └────┘
</code></pre>
<p>We know all of those lines need to be joined <em>somewhere</em>, but we don’t quite
know <em>where</em> yet. This is where we need to bring in our first rule, a rule that
universally governs all accesses to every location in memory:</p>
<blockquote>
<p>From the point at which the access occurs, find every other point that can be
reached by following the reverse direction of arrows, then for each one of
those, take a single step across every line that connects to the relevant
memory location. <strong>It is not allowed for the access to read or write any value
that appears above any one of these points</strong>.</p>
</blockquote>
<p>In our case, there are two potential executions: one, where the first write
corresponds to the first value in <code>data</code>, and two, where the first write
corresponds to the second value in <code>data</code>. Considering the second case for a
moment, it would also force the second write to correspond to the first
value in <code>data</code>. Therefore its diagram would look something like this:</p>
<pre><code class="language-text"> Thread 1        data
╭───────╮       ┌────┐
│  = 1  ├╌╌┐    │  0 │
╰───╥───╯  ┊ ┌╌╌┼╌╌╌╌┤
╭───⇓───╮  ┊ ├╌╌┼╌╌╌╌┤
│  data ├╌?┊ ┊  │  2 │
╰───╥───╯  ├╌┼╌╌┼╌╌╌╌┤
╭───⇓───╮  └╌┼╌╌┼╌╌╌╌┤
│  = 2  ├╌╌╌╌┘  │  1 │
╰───────╯       └────┘
</code></pre>
<p>However, that second line breaks the rule we just established! Following up the
arrows from the third operation in Thread 1, we reach the first operation, and
from there we can take a single step to reach the space in between the <code>2</code> and
the <code>1</code>, which excludes the third access from writing any value above that point
— including the <code>2</code> that it is currently writing!</p>
<p>So evidently, this execution is no good. We can therefore conclude that the only
possible execution of this program is the other one, in which the <code>1</code> appears
above the <code>2</code>:</p>
<pre><code class="language-text"> Thread 1     data
╭───────╮     ┌────┐
│  = 1  ├╌╌┐  │  0 │
╰───╥───╯  ├╌╌┼╌╌╌╌┤
╭───⇓───╮  └╌╌┼╌╌╌╌┤
│  data ├╌?   │  1 │
╰───╥───╯  ┌╌╌┼╌╌╌╌┤
╭───⇓───╮  ├╌╌┼╌╌╌╌┤
│  = 2  ├╌╌┘  │  2 │
╰───────╯     └────┘
</code></pre>
<p>Now to sort out the read operation in the middle. We can use the same rule as
before to trace up to the first write and rule out us reading either the <code>0</code>
value or the garbage that exists between it and <code>1</code>, but how to we choose
between the <code>1</code> and the <code>2</code>? Well, as it turns out there is a complement to the
rule we already defined which gives us the exact answer we need:</p>
<blockquote>
<p>From the point at which the access occurs, find every other point that can be
reached by following the <em>forward</em> direction of arrows, then for each one of
those, take a single step across every line that connects to the relevant
memory location. <strong>It is not allowed for the access to read or write any value
that appears below any one of these points</strong>.</p>
</blockquote>
<p>Using this rule, we can follow the arrow downwards and then across and finally
rule out <code>2</code> as well as the garbage before it. This leaves us with exactly <em>one</em>
value that the read operation can return, and exactly one possible execution
guaranteed by the Abstract Machine:</p>
<pre><code class="language-text"> Thread 1      data
╭───────╮     ┌────┐
│  = 1  ├╌╌┐  │  0 │
╰───╥───╯  ├╌╌┼╌╌╌╌┤
╭───⇓───╮  └╌╌┼╌╌╌╌┤
│  data ├╌╌╌╌╌┤  1 │
╰───╥───╯  ┌╌╌┼╌╌╌╌┤
╭───⇓───╮  ├╌╌┼╌╌╌╌┤
│  = 2  ├╌╌┘  │  2 │
╰───────╯     └────┘
</code></pre>
<p>These two rules combined make up the more generalized rule known as <em>coherence</em>,
which is put in place to guarantee that a thread will never see a value earlier
than the last one it read or later than a one it will in future write. Coherence
is basically required for any program to act in a sane way, so luckily the C++20
standard guarantees it as one of its most fundamental principles.</p>
<p>You might be thinking that all this has been is the longest, most convoluted
explanation ever of the most basic intuitive semantics of programming — and
you’d be absolutely right. But it’s essential to grasp these fundamentals,
because once you have this model in mind, the extension into multiple threads
and the complicated semantics of real atomics becomes completely natural.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../atomics/atomics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../atomics/relaxed.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../atomics/atomics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../atomics/relaxed.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
