<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SeqCst - The Rustonomicon</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/nomicon.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> Meet Safe and Unsafe</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> How Safe and Unsafe Interact</a></li><li class="chapter-item expanded "><a href="../what-unsafe-does.html"><strong aria-hidden="true">1.2.</strong> What Unsafe Can Do</a></li><li class="chapter-item expanded "><a href="../working-with-unsafe.html"><strong aria-hidden="true">1.3.</strong> Working with Unsafe</a></li></ol></li><li class="chapter-item expanded "><a href="../data.html"><strong aria-hidden="true">2.</strong> Data Layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li class="chapter-item expanded "><a href="../exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> Exotically Sized Types</a></li><li class="chapter-item expanded "><a href="../other-reprs.html"><strong aria-hidden="true">2.3.</strong> Other reprs</a></li></ol></li><li class="chapter-item expanded "><a href="../ownership.html"><strong aria-hidden="true">3.</strong> Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../references.html"><strong aria-hidden="true">3.1.</strong> References</a></li><li class="chapter-item expanded "><a href="../aliasing.html"><strong aria-hidden="true">3.2.</strong> Aliasing</a></li><li class="chapter-item expanded "><a href="../lifetimes.html"><strong aria-hidden="true">3.3.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="../lifetime-mismatch.html"><strong aria-hidden="true">3.4.</strong> Limits of Lifetimes</a></li><li class="chapter-item expanded "><a href="../lifetime-elision.html"><strong aria-hidden="true">3.5.</strong> Lifetime Elision</a></li><li class="chapter-item expanded "><a href="../unbounded-lifetimes.html"><strong aria-hidden="true">3.6.</strong> Unbounded Lifetimes</a></li><li class="chapter-item expanded "><a href="../hrtb.html"><strong aria-hidden="true">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class="chapter-item expanded "><a href="../subtyping.html"><strong aria-hidden="true">3.8.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="../dropck.html"><strong aria-hidden="true">3.9.</strong> Drop Check</a></li><li class="chapter-item expanded "><a href="../phantom-data.html"><strong aria-hidden="true">3.10.</strong> PhantomData</a></li><li class="chapter-item expanded "><a href="../borrow-splitting.html"><strong aria-hidden="true">3.11.</strong> Splitting Borrows</a></li></ol></li><li class="chapter-item expanded "><a href="../conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../coercions.html"><strong aria-hidden="true">4.1.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="../dot-operator.html"><strong aria-hidden="true">4.2.</strong> The Dot Operator</a></li><li class="chapter-item expanded "><a href="../casts.html"><strong aria-hidden="true">4.3.</strong> Casts</a></li><li class="chapter-item expanded "><a href="../transmutes.html"><strong aria-hidden="true">4.4.</strong> Transmutes</a></li></ol></li><li class="chapter-item expanded "><a href="../uninitialized.html"><strong aria-hidden="true">5.</strong> Uninitialized Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../checked-uninit.html"><strong aria-hidden="true">5.1.</strong> Checked</a></li><li class="chapter-item expanded "><a href="../drop-flags.html"><strong aria-hidden="true">5.2.</strong> Drop Flags</a></li><li class="chapter-item expanded "><a href="../unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> Unchecked</a></li></ol></li><li class="chapter-item expanded "><a href="../obrm.html"><strong aria-hidden="true">6.</strong> Ownership Based Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../constructors.html"><strong aria-hidden="true">6.1.</strong> Constructors</a></li><li class="chapter-item expanded "><a href="../destructors.html"><strong aria-hidden="true">6.2.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="../leaking.html"><strong aria-hidden="true">6.3.</strong> Leaking</a></li></ol></li><li class="chapter-item expanded "><a href="../unwinding.html"><strong aria-hidden="true">7.</strong> Unwinding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exception-safety.html"><strong aria-hidden="true">7.1.</strong> Exception Safety</a></li><li class="chapter-item expanded "><a href="../poisoning.html"><strong aria-hidden="true">7.2.</strong> Poisoning</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency.html"><strong aria-hidden="true">8.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../races.html"><strong aria-hidden="true">8.1.</strong> Races</a></li><li class="chapter-item expanded "><a href="../send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="../atomics/atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../atomics/multithread.html"><strong aria-hidden="true">8.3.1.</strong> Multithreaded Execution</a></li><li class="chapter-item expanded "><a href="../atomics/relaxed.html"><strong aria-hidden="true">8.3.2.</strong> Relaxed</a></li><li class="chapter-item expanded "><a href="../atomics/acquire-release.html"><strong aria-hidden="true">8.3.3.</strong> Acquire and Release</a></li><li class="chapter-item expanded "><a href="../atomics/seqcst.html" class="active"><strong aria-hidden="true">8.3.4.</strong> SeqCst</a></li><li class="chapter-item expanded "><a href="../atomics/fences.html"><strong aria-hidden="true">8.3.5.</strong> Fences</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../vec/vec.html"><strong aria-hidden="true">9.</strong> Implementing Vec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../vec/vec-layout.html"><strong aria-hidden="true">9.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="../vec/vec-alloc.html"><strong aria-hidden="true">9.2.</strong> Allocating</a></li><li class="chapter-item expanded "><a href="../vec/vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> Push and Pop</a></li><li class="chapter-item expanded "><a href="../vec/vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> Deallocating</a></li><li class="chapter-item expanded "><a href="../vec/vec-deref.html"><strong aria-hidden="true">9.5.</strong> Deref</a></li><li class="chapter-item expanded "><a href="../vec/vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> Insert and Remove</a></li><li class="chapter-item expanded "><a href="../vec/vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="../vec/vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li class="chapter-item expanded "><a href="../vec/vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li class="chapter-item expanded "><a href="../vec/vec-zsts.html"><strong aria-hidden="true">9.10.</strong> Handling Zero-Sized Types</a></li><li class="chapter-item expanded "><a href="../vec/vec-final.html"><strong aria-hidden="true">9.11.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-and-mutex.html"><strong aria-hidden="true">10.</strong> Implementing Arc and Mutex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arc-mutex/arc.html"><strong aria-hidden="true">10.1.</strong> Arc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arc-mutex/arc-layout.html"><strong aria-hidden="true">10.1.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-base.html"><strong aria-hidden="true">10.1.2.</strong> Base Code</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-clone.html"><strong aria-hidden="true">10.1.3.</strong> Cloning</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-drop.html"><strong aria-hidden="true">10.1.4.</strong> Dropping</a></li><li class="chapter-item expanded "><a href="../arc-mutex/arc-final.html"><strong aria-hidden="true">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../ffi.html"><strong aria-hidden="true">11.</strong> FFI</a></li><li class="chapter-item expanded "><a href="../beneath-std.html"><strong aria-hidden="true">12.</strong> Beneath std</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../panic-handler.html"><strong aria-hidden="true">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/nomicon" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="seqcst"><a class="header" href="#seqcst">SeqCst</a></h1>
<p><code>SeqCst</code> is probably the most interesting ordering, because it is simultaneously
the simplest and most complex atomic memory ordering in existence. It’s
simple, because if you do only use <code>SeqCst</code> everywhere then you can kind of
maybe pretend like the Abstract Machine has a concept of time; phrases like
“latest value” make sense, the program can be thought of as a set of steps that
interleave, there is a universal “now” and “before” and wouldn’t that be nice?
But it’s also the most complex, because as soon as look under the hood you
realize just how incredibly convoluted and hard to follow the actual rules
behind it are, and it gets really ugly really fast as soon as you try to mix it
with any other ordering.</p>
<p>To understand <code>SeqCst</code>, we first have to understand the problem it exists to
solve. The first complexity is that this problem can only be observed in the
presence of at least four different threads <em>and</em> two separate atomic variables;
anything less and it’s not possible to notice a difference. The common example
used to show where weaker orderings produce counterintuitive results is this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::atomic::{self, AtomicBool};
</span>use std::thread;

// Set this to Relaxed, Acquire, Release, AcqRel, doesn’t matter — the result is
// the same (modulo panics caused by attempting acquire stores or release
// loads).
const ORDERING: atomic::Ordering = atomic::Ordering::Relaxed;

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);

let a = thread::spawn(|| { X.store(true, ORDERING) });
let b = thread::spawn(|| { Y.store(true, ORDERING) });
let c = thread::spawn(|| { while !X.load(ORDERING) {} Y.load(ORDERING) });
let d = thread::spawn(|| { while !Y.load(ORDERING) {} X.load(ORDERING) });

let a = a.join().unwrap();
let b = b.join().unwrap();
let c = c.join().unwrap();
let d = d.join().unwrap();

<span class="boring">return;
</span>// This assert is allowed to fail.
assert!(c || d);
<span class="boring">}</span></code></pre></pre>
<p>The basic setup of this code, for all of its possible executions, looks like
this:</p>
<pre><code class="language-text">     a        static X         c               d        static Y         b
╭─────────╮   ┌───────┐   ╭─────────╮     ╭─────────╮   ┌───────┐   ╭─────────╮
│ store X ├─┐ │ false │ ┌─┤ load X  │     │ load Y  ├─┐ │ false │ ┌─┤ store Y │
╰─────────╯ │ └───────┘ │ ╰────╥────╯     ╰────╥────╯ │ └───────┘ │ ╰─────────╯
            └─┬───────┐ │ ╭────⇓────╮     ╭────⇓────╮ │ ┌───────┬─┘
              │ true  ├─┘ │ load Y  ├─? ?─┤ load X  │ └─┤ true  │
              └───────┘   ╰─────────╯     ╰─────────╯   └───────┘
</code></pre>
<p>In other words, <code>a</code> and <code>b</code> are guaranteed to, at some point, store <code>true</code> into
<code>X</code> and <code>Y</code> respectively, and <code>c</code> and <code>d</code> are guaranteed to, at some point, load
those values of <code>true</code> from <code>X</code> and <code>Y</code> (there could also be an arbitrary number
of loads of <code>false</code> by <code>c</code> and <code>d</code>, but they’ve been omitted since they don’t
actually affect the execution at all). The question now is when <code>c</code> and <code>d</code> load
from <code>Y</code> and <code>X</code> respectively, is it possible for them <em>both</em> to load <code>false</code>?</p>
<p>And looking at this diagram, there’s absolutely no reason why not. There isn’t
even a single arrow connecting the left and right hand sides so far, so the load
has no coherence-based restrictions on which value it is allowed to pick — and
this goes for both sides equally, so we could end up with an execution like
this:</p>
<pre><code class="language-text">     a        static X         c             d        static Y         b
╭─────────╮   ┌───────┐   ╭─────────╮   ╭─────────╮   ┌───────┐   ╭─────────╮
│ store X ├─┐ │ false ├┐ ┌┤ load X  │   │ load Y  ├┐ ┌┤ false │ ┌─┤ store Y │
╰─────────╯ │ └───────┘│ │╰────╥────╯   ╰────╥────╯│ │└───────┘ │ ╰─────────╯
            └─┬───────┐└─│─────║──────┐┌─────║─────│─┘┌───────┬─┘
              │ true  ├──┘╭────⇓────╮┌─┘╭────⇓────╮└──┤ true  │
              └───────┘   │ load Y  ├┘└─┤ load X  │   └───────┘
                          ╰─────────╯   ╰─────────╯
</code></pre>
<p>Which results in a failed assert. This execution is brought about because the
model of separate modification orders means that there is no relative ordering
between <code>X</code> and <code>Y</code> being changed, and so each thread is allowed to “see” either
order. However, some algorithms will require a globally agreed-upon ordering,
and this is where <code>SeqCst</code> can come in useful.</p>
<p>This ordering, first and foremost, inherits the guarantees from all the other
orderings — it is an acquire operation for loads, a release operation for stores
and an acquire-release operation for RMWs. In addition to this, it gives some
guarantees unique to <code>SeqCst</code> about what values it is allowed to load. Note that
these guarantees are not about preventing data races: unless you have some
unrelated code that triggers a data race given an unexpected condition, using
<code>SeqCst</code> can only prevent you from race conditions because its guarantees only
apply to other <code>SeqCst</code> operations rather than all data accesses.</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<p><code>SeqCst</code> is fundamentally about <em>S</em>, which is the global ordering of all
<code>SeqCst</code> operations in an execution of the program. It is consistent between
every atomic and every thread, and all stores, fences and RMWs that use a
sequentially consistent ordering have a place in it (but no other operations
do). It is in contrast to modification orders, which are similarly total but
only scoped to a single atomic rather than the whole program.</p>
<p>Other than an edge case involving <code>SeqCst</code> mixed with weaker orderings (detailed
later on), <em>S</em> is primarily controlled by the happens-before relations in a
program: this means that if an action <em>A</em> happens-before an action <em>B</em>, it is
also guaranteed to appear before <em>B</em> in <em>S</em>. Other than that restriction, <em>S</em> is
unspecified and will be chosen arbitrarily during execution.</p>
<p>Once a particular <em>S</em> has been established, every atomic’s modification order is
then guaranteed to be consistent with it, so a <code>SeqCst</code> load will never see a
value that has been overwritten by a write that occurred before it in <em>S</em>, or a
value that has been written by a write that occured after it in <em>S</em> (note that a
<code>Relaxed</code>/<code>Acquire</code> load however might, since there is no “before” or “after” as
it is not in <em>S</em> in the first place).</p>
<p>More formally, this guarantee can be described with <em>coherence orderings</em>, a
relation which expresses which of two operations appears before the other in an
atomic’s modification order. It is said that an operation <em>A</em> is
<em>coherence-ordered-before</em> another operation <em>B</em> if any of the following
conditions are met:</p>
<ol>
<li><em>A</em> is a store or RMW, <em>B</em> is a store or RMW, and <em>A</em> appears before <em>B</em> in
the modification order.</li>
<li><em>A</em> is a store or RMW, <em>B</em> is a load, and <em>B</em> reads the value stored by <em>A</em>.</li>
<li><em>A</em> is a load, <em>B</em> is a store or RMW, and <em>A</em> takes its value from a place in
the modification order that appears before <em>B</em>.</li>
<li><em>A</em> is coherence-ordered-before a different operation <em>X</em>, and <em>X</em> is
coherence-ordered-before <em>B</em> (the basic transitivity property).</li>
</ol>
<p>The following diagram gives examples for the main three rules (in each case <em>A</em>
is coherence-ordered-before <em>B</em>):</p>
<pre><code class="language-text">        Rule 1        ┃         Rule 2        ┃         Rule 3
                      ┃                       ┃
╭───╮ ┌─┬───┐   ╭───╮ ┃ ╭───╮ ┌─┬───┐   ╭───╮ ┃ ╭───╮   ┌───┐   ╭───╮
│ A ├─┘ │   │ ┌─┤ B │ ┃ │ A ├─┘ │   ├───┤ B │ ┃ │ A ├───┤   │ ┌─┤ B │
╰───╯   └───┘ │ ╰───╯ ┃ ╰───╯   └───┘   ╰───╯ ┃ ╰───╯   └───┘ │ ╰───╯
        ┌───┬─┘       ┃                       ┃         ┌───┬─┘
        │   │         ┃                       ┃         │   │
        └───┘         ┃                       ┃         └───┘
</code></pre>
<p>The only important thing to note is that for two loads of the same value in the
modification order, neither is coherence-ordered-before the other, as in the
following example where <em>A</em> has no coherence ordering relation to <em>B</em>:</p>
<pre><code class="language-text">╭───╮   ┌───┐   ╭───╮
│ A ├───┤   ├───┤ B │
╰───╯   └───┘   ╰───╯
</code></pre>
<p>Because of this, “<em>A</em> is coherence-ordered-before <em>B</em>” is subtly different from
“<em>A</em> is not coherence-ordered-after <em>B</em>”; only the latter phrase includes the
above situation, and is synonymous with “either <em>A</em> is coherence-ordered-before
<em>B</em> or <em>A</em> and <em>B</em> are both loads, and see the same value in the atomic’s
modification order”. “Not coherence-ordered-after” is generally a more useful
relation than “coherence-ordered-before”, and so it’s important to understand
what it means.</p>
<p>With this terminology applied, we can use a more precise definition of
<code>SeqCst</code>’s guarantee: for two <code>SeqCst</code> operations on the same atomic <em>A</em> and
<em>B</em>, where <em>A</em> precedes <em>B</em> in <em>S</em>, <em>A</em> is not coherence-ordered-after <em>B</em>.
Effectively, this one rule ensures that <em>S</em>’s order “propagates”
throughout all the atomics of the program — you can imagine each operation in
<em>S</em> as storing a snapshot of the world, so that every subsequent operation is
consistent with it.</p>
<h2 id="applying-seqcst"><a class="header" href="#applying-seqcst">Applying <code>SeqCst</code></a></h2>
<p>So, looking back at our program, let’s consider how we could use <code>SeqCst</code> to
make that execution invalid. As a refresher, here’s the framework for every
possible execution of the program:</p>
<pre><code class="language-text">     a        static X         c               d        static Y         b
╭─────────╮   ┌───────┐   ╭─────────╮     ╭─────────╮   ┌───────┐   ╭─────────╮
│ store X ├─┐ │ false │ ┌─┤ load X  │     │ load Y  ├─┐ │ false │ ┌─┤ store Y │
╰─────────╯ │ └───────┘ │ ╰────╥────╯     ╰────╥────╯ │ └───────┘ │ ╰─────────╯
            └─┬───────┐ │ ╭────⇓────╮     ╭────⇓────╮ │ ┌───────┬─┘
              │ true  ├─┘ │ load Y  ├─? ?─┤ load X  │ └─┤ true  │
              └───────┘   ╰─────────╯     ╰─────────╯   └───────┘
</code></pre>
<p>First of all, both the final loads (<code>c</code> and <code>d</code>’s second operations) need to
become <code>SeqCst</code>, because they need to be aware of the total ordering that
determines whether <code>X</code> or <code>Y</code> becomes <code>true</code> first. And secondly, we need to
establish that ordering in the first place, and that needs to be done by making
sure that there is always one operation in <em>S</em> that both sees one of the atomics
as <code>true</code> and precedes both final loads in <em>S</em>, so that the coherence ordering
guarantee will apply (the final loads themselves don’t work for this since
although they “know” that their corresponding atomic is <code>true</code> they don’t
interact with it directly so <em>S</em> doesn’t care).</p>
<p>There are two operations in the program that could fulfill the first condition,
should they be made <code>SeqCst</code>: the stores of <code>true</code> and the first loads. However,
the second condition ends up ruling out using the stores, since in order to make
sure that they precede the final loads in <em>S</em> it would be necessary to have the
first loads be <code>SeqCst</code> anyway (due to the mixed-<code>SeqCst</code> special case detailed
later), so in the end we can just leave them as <code>Relaxed</code>.</p>
<p>This leaves us with the correct version of the above program, which is
guaranteed to never panic:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering::{Relaxed, SeqCst}};
</span>use std::thread;

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);

let a = thread::spawn(|| { X.store(true, Relaxed) });
let b = thread::spawn(|| { Y.store(true, Relaxed) });
let c = thread::spawn(|| { while !X.load(SeqCst) {} Y.load(SeqCst) });
let d = thread::spawn(|| { while !Y.load(SeqCst) {} X.load(SeqCst) });

let a = a.join().unwrap();
let b = b.join().unwrap();
let c = c.join().unwrap();
let d = d.join().unwrap();

// This assert is **not** allowed to fail.
assert!(c || d);
<span class="boring">}</span></code></pre></pre>
<p>As there are four <code>SeqCst</code> operations with a partial order between two pairs in
them (caused by the sequenced-before relation), there are six possible
executions of this program:</p>
<ul>
<li>All of <code>c</code>’s loads precede <code>d</code>’s loads:
<ol>
<li><code>c</code> loads <code>X</code> (gives <code>true</code>)</li>
<li><code>c</code> loads <code>Y</code> (gives either <code>false</code> or <code>true</code>)</li>
<li><code>d</code> loads <code>Y</code> (gives <code>true</code>)</li>
<li><code>d</code> loads <code>X</code> (required to be <code>true</code>)</li>
</ol>
</li>
<li>Both initial loads precede both final loads:
<ol>
<li><code>c</code> loads <code>X</code> (gives <code>true</code>)</li>
<li><code>d</code> loads <code>Y</code> (gives <code>true</code>)</li>
<li><code>c</code> loads <code>Y</code> (required to be <code>true</code>)</li>
<li><code>d</code> loads <code>X</code> (required to be <code>true</code>)</li>
</ol>
</li>
<li>As above, but the final loads occur in a different order:
<ol>
<li><code>c</code> loads <code>X</code> (gives <code>true</code>)</li>
<li><code>d</code> loads <code>Y</code> (gives <code>true</code>)</li>
<li><code>d</code> loads <code>X</code> (required to be <code>true</code>)</li>
<li><code>c</code> loads <code>Y</code> (required to be <code>true</code>)</li>
</ol>
</li>
<li>As before, but the initial loads occur in a different order:
<ol>
<li><code>d</code> loads <code>Y</code> (gives <code>true</code>)</li>
<li><code>c</code> loads <code>X</code> (gives <code>true</code>)</li>
<li><code>c</code> loads <code>Y</code> (required to be <code>true</code>)</li>
<li><code>d</code> loads <code>X</code> (required to be <code>true</code>)</li>
</ol>
</li>
<li>As above, but the final loads occur in a different order:
<ol>
<li><code>d</code> loads <code>Y</code> (gives <code>true</code>)</li>
<li><code>c</code> loads <code>X</code> (gives <code>true</code>)</li>
<li><code>d</code> loads <code>X</code> (required to be <code>true</code>)</li>
<li><code>c</code> loads <code>Y</code> (required to be <code>true</code>)</li>
</ol>
</li>
<li>All of <code>d</code>’s loads precede <code>c</code>’s loads:
<ol>
<li><code>d</code> loads <code>Y</code> (gives <code>true</code>)</li>
<li><code>d</code> loads <code>X</code> (gives either <code>false</code> or <code>true</code>)</li>
<li><code>c</code> loads <code>X</code> (gives <code>true</code>)</li>
<li><code>c</code> loads <code>Y</code> (required to be <code>true</code>)</li>
</ol>
</li>
</ul>
<p>All the places where the load was required to give <code>true</code> were caused by a
preceding load in <em>S</em> of the same atomic which saw <code>true</code> — otherwise, the load
would be coherence-ordered-before a load which precedes it in <em>S</em>, and that is
impossible.</p>
<h2 id="the-mixed-seqcst-special-case"><a class="header" href="#the-mixed-seqcst-special-case">The mixed-<code>SeqCst</code> special case</a></h2>
<p>As I’ve been alluding to for a while, I wasn’t being totally truthful when I
said that <em>S</em> is consistent with happens-before relations — in reality, it is
only consistent with <em>strongly happens-before</em> relations, which presents a
subtly-defined subset of happens-before relations. In particular, it excludes
two situations:</p>
<ol>
<li>The <code>SeqCst</code> operation A synchronizes-with an <code>Acquire</code> or <code>AcqRel</code> operation
B which is sequenced-before another <code>SeqCst</code> operation C. Here, despite the
fact that A happens-before C, A does not <em>strongly</em> happen-before C and so is
not guaranteed to precede C in <em>S</em>.</li>
<li>The <code>SeqCst</code> operation A is sequenced-before the <code>Release</code> or <code>AcqRel</code>
operation B, which synchronizes-with another <code>SeqCst</code> operation C. Similarly,
despite the fact that A happens-before C, A might not precede C in <em>S</em>.</li>
</ol>
<p>The first situation is illustrated below, with <code>SeqCst</code> accesses repesented with
asterisks:</p>
<pre><code class="language-text">  t_1       x       t_2
╭─────╮ ┌─↘───┐   ╭─────╮
│ *A* ├─┘ │ 1 ├───→  B  │
╰─────╯   └───┘   ╰──╥──╯
                  ╭──⇓──╮
                  │ *C* │
                  ╰─────╯
</code></pre>
<p>A happens-before, but does not strongly happen-before, C — and anything
sequenced-after C will have the same treatment (unless more synchronization is
used). This means that C is actually allowed to <em>precede</em> A in <em>S</em>, despite
conceptually occuring after it. However, anything sequenced-before A, because
there is at least one sequence on either side of the synchronization, will
strongly happen-before C.</p>
<p>But this is all highly theoretical at the moment, so let’s make an example to
show how that rule can actually affect the execution of code. So, if C were to
precede A in <em>S</em> (and they are not both loads) then that means C is always
coherence-ordered-before A. Let’s say then that C loads from <code>x</code> (the atomic
that A has to access), it may load the value that came before A if it were to
precede A in <em>S</em>:</p>
<pre><code class="language-text">  t_1       x       t_2
╭─────╮   ┌───┐   ╭─────╮
│ *A* ├─┐ │ 0 ├─┐┌→  B  │
╰─────╯ │ └───┘ ││╰──╥──╯
        └─↘───┐┌─┘╭──⇓──╮
          │ 1 ├┘└─→ *C* │
          └───┘   ╰─────╯
</code></pre>
<p>Ah wait no, that doesn’t work because regular coherence still mandates that <code>1</code>
is the only value that can be loaded. In fact, once <code>1</code> is loaded <em>S</em>’s required
consistency with coherence orderings means that A <em>is</em> required to precede C in
<em>S</em> after all.</p>
<p>So somehow, to observe this difference we need to have a <em>different</em> <code>SeqCst</code>
operation, let’s call it E, be the one that loads from <code>x</code>, where C is
guaranteed to precede it in <em>S</em> (so we can observe the “weird” state in between
C and A) but C also doesn’t happen-before it (to avoid coherence getting in the
way) — and to do that, all we have to do is have C appear before a <code>SeqCst</code>
operation D in the modification order of another atomic, but have D be a store
so as to avoid C synchronizing with it, and then our desired load E can simply
be sequenced-after D (this will carry over the “precedes in <em>S</em>” guarantee, but
does not restore the happens-after relation to C since that was already dropped
by having D be a store).</p>
<p>In diagram form, that looks like this:</p>
<pre><code class="language-text">  t_1       x       t_2     helper      t_3
╭─────╮   ┌───┐   ╭─────╮   ┌─────┐   ╭─────╮
│ *A* ├─┐ │ 0 ├┐┌─→  B  │ ┌─┤  0  │ ┌─┤ *D* │
╰─────╯ │ └───┘││ ╰──╥──╯ │ └─────┘ │ ╰──╥──╯
        │      └│────║────│─────────│┐   ║
        └─↘───┐ │ ╭──⇓──╮ │ ┌─────↙─┘│╭──⇓──╮
          │ 1 ├─┘ │ *C* ←─┘ │  1  │  └→ *E* │
          └───┘   ╰─────╯   └─────┘   ╰─────╯

S = C → D → E → A
</code></pre>
<p>C is guaranteed to precede D in <em>S</em>, and D is guaranteed to precede E, but
because this exception means that A is <em>not</em> guaranteed to precede C, it is
totally possible for it to come at the end, resulting in the surprising but
totally valid outcome of E loading <code>0</code> from <code>x</code>. In code, this can be expressed
as the following code <em>not</em> being guaranteed to panic:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::atomic::{AtomicU8, Ordering::{Acquire, SeqCst}};
</span><span class="boring">return;
</span>static X: AtomicU8 = AtomicU8::new(0);
static HELPER: AtomicU8 = AtomicU8::new(0);

// thread_1
X.store(1, SeqCst); // A

// thread_2
assert_eq!(X.load(Acquire), 1); // B
assert_eq!(HELPER.load(SeqCst), 0); // C

// thread_3
HELPER.store(1, SeqCst); // D
assert_eq!(X.load(SeqCst), 0); // E
<span class="boring">}</span></code></pre></pre>
<p>The second situation listed above has very similar consequences. Its abstract
form is the following execution in which A is not guaranteed to precede C in
<em>S</em>, despite A happening-before C:</p>
<pre><code class="language-text">  t_1       x       t_2
╭─────╮ ┌─↘───┐   ╭─────╮
│ *A* │ │ │ 0 ├───→ *C* │
╰──╥──╯ │ └───┘   ╰─────╯
╭──⇓──╮ │
│  B  ├─┘
╰─────╯
</code></pre>
<p>Similarly to before, we can’t just have A access <code>x</code> to show why A not
necessarily preceding C in <em>S</em> matters; instead, we have to introduce a second
atomic and third thread to break the happens-before chain first. And finally, a
single relaxed load F at the end is added just to prove that the weird execution
actually happened (leaving <code>x</code> as 2 instead of 1).</p>
<pre><code class="language-text">  t_3     helper      t_1       x       t_2
╭─────╮   ┌─────┐   ╭─────╮   ┌───┐   ╭─────╮
│ *D* ├┐┌─┤  0  │ ┌─┤ *A* │   │ 0 │ ┌─→ *C* │
╰──╥──╯││ └─────┘ │ ╰──╥──╯   └───┘ │ ╰──╥──╯
   ║   └│─────────│────║─────┐      │    ║
╭──⇓──╮ │ ┌─────↙─┘ ╭──⇓──╮ ┌─↘───┐ │ ╭──⇓──╮
│ *E* ←─┘ │  1  │   │  B  ├─┘││ 1 ├─┘┌┤  F  │
╰─────╯   └─────┘   ╰─────╯  │└───┘  │╰─────╯
                             └↘───┐  │
                              │ 2 ├──┘
                              └───┘
S = C → D → E → A
</code></pre>
<p>This execution mandates both C preceding A in <em>S</em> and A happening-before C,
something that is only possible through these two mixed-<code>SeqCst</code> special
exceptions. It can be expressed in code as well:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::atomic::{AtomicU8, Ordering::{Release, Relaxed, SeqCst}};
</span><span class="boring">return;
</span>static X: AtomicU8 = AtomicU8::new(0);
static HELPER: AtomicU8 = AtomicU8::new(0);

// thread_3
X.store(2, SeqCst); // D
assert_eq!(HELPER.load(SeqCst), 0); // E

// thread_1
HELPER.store(1, SeqCst); // A
X.store(1, Release); // B

// thread_2
assert_eq!(X.load(SeqCst), 1); // C
assert_eq!(X.load(Relaxed), 2); // F
<span class="boring">}</span></code></pre></pre>
<p>If this seems ridiculously specific and obscure, that’s because it is.
Originally, back in C++11, this special case didn’t exist — but then six years
later it was discovered that in practice atomics on Power, Nvidia GPUs and
sometimes ARMv7 <em>would</em> have this special case, and fixing the implementations
would make atomics significantly slower. So instead, in C++20 they simply
encoded it into the specification.</p>
<p>Generally however, this rule is so complex it’s best to just avoid it entirely
by never mixing <code>SeqCst</code> and non-<code>SeqCst</code> on a single atomic in the first place.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../atomics/acquire-release.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../atomics/fences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../atomics/acquire-release.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../atomics/fences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
